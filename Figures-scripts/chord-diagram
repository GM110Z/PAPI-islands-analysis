library(circlize)

# --- Load and clean similarity matrix ---
mat <- read.table("proteome_similarity_matrix.tsv", header = TRUE, sep = "\t", row.names = 1)
mat <- as.matrix(mat)
diag(mat) <- 0
mat[is.na(mat)] <- 0

# --- Filter: keep only similarity >= 0.30 (no reciprocity; draw once per pair) ---
thr <- 0.40
mat_filtered <- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))

if (nrow(mat) >= 2) {
  for (i in seq_len(nrow(mat) - 1)) {                     # safe upper-triangle loop
    for (j in seq.int(i + 1, ncol(mat))) {
      w <- max(mat[i, j], mat[j, i])                      # take stronger direction
      if (!is.na(w) && w >= thr) {
        mat_filtered[i, j] <- w                           # keep only i->j; j->i stays 0
      }
    }
  }
}

# --- PDF Output ---
pdf("chord_diagram_filtered.pdf", width = 10, height = 10)

# --- Circos settings ---
circos.clear()
circos.par(start.degree = 90, gap.degree = 4, track.margin = c(0.01, 0.01))

# --- Plot chord diagram ---
chordDiagram(
  mat_filtered,
  transparency = 0.5,
  annotationTrack = "grid",
  preAllocateTracks = list(track.height = 0.1)
)

# --- Rotated labels, positioned closer to circle ---
circos.trackPlotRegion(
  track.index = 1,
  panel.fun = function(x, y) {
    sector.name <- get.cell.meta.data("sector.index")
    xlim <- get.cell.meta.data("xlim")
    ylim <- get.cell.meta.data("ylim")
    circos.text(
      x = mean(xlim),
      y = ylim[1] + 0.3,
      labels = sector.name,
      facing = "clockwise",
      niceFacing = FALSE,
      adj = c(0, 0),
      cex = 0.7
    )
  },
  bg.border = NA
)

# --- Legend (threshold updated) ---
legend(
  "topleft",
  legend = c(
    "Chord width ~ similarity score",
    "Only similarity >= 0.40 shown"
  ),
  bty = "n",
  cex = 0.9,
  text.col = "black"
)

# --- Save PDF ---
dev.off()
